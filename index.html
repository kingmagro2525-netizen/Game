<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Fortnite Mobile Survival & Memory Game Fixed</title>
    <style>
        /* === ÂÖÉ„ÅÆCSS („Éê„Éà„É≠„ÉØÁî®) === */
        body { 
            margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; 
            touch-action: none; user-select: none; -webkit-user-select: none;
            background: #000; color: white;
        }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10; display: none;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 16px; height: 16px;
            background: transparent; border: 2px solid rgba(255, 255, 255, 0.9); 
            border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 4px black;
        }
        #status-bar {
            position: absolute; top: 10px; left: 0; width: 100%;
            display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box;
            font-weight: bold; font-size: 18px; color: white; text-shadow: 2px 2px 0 #000;
        }
        #hp-bar { color: #00ff00; }
        #score-bar { color: #ffff00; }
        #players-bar { color: #00ffff; }
        #connection-status {
            position: absolute; top: 50px; left: 20px;
            color: white; font-size: 14px; text-shadow: 2px 2px 0 #000; pointer-events: none;
        }
        /* „ÉÅ„É£„ÉÉ„Éà */
        #chat-container {
            position: absolute; top: 80px; right: 20px; width: 300px; max-width: 40%; pointer-events: auto;
        }
        #chat-messages {
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px;
            max-height: 200px; overflow-y: auto; margin-bottom: 10px; font-size: 14px; color: white;
        }
        .chat-message { margin: 5px 0; word-wrap: break-word; }
        .chat-username { color: #4caf50; font-weight: bold; }
        #chat-input-container { display: flex; gap: 5px; }
        #chat-input {
            flex: 1; padding: 10px; font-size: 14px; border: 2px solid #4caf50;
            border-radius: 5px; background: rgba(0,0,0,0.7); color: white;
        }
        #chat-send {
            padding: 10px 20px; background: #4caf50; color: white; border: none; border-radius: 5px; cursor: pointer;
        }
        #game-over {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none;
            flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 20; pointer-events: auto;
        }
        #restart-btn {
            margin-top: 20px; padding: 15px 30px; font-size: 20px;
            background: #ff4444; color: white; border: none; border-radius: 5px;
        }
        .control-btn {
            position: absolute; background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.4); color: white; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 14px; pointer-events: auto; touch-action: manipulation;
            transition: transform 0.1s;
        }
        .control-btn:active { background: rgba(255, 255, 255, 0.3); transform: scale(0.95); }
        #btn-shoot { width: 75px; height: 75px; bottom: 80px; right: 30px; background: rgba(255, 50, 50, 0.6); }
        #btn-jump  { width: 60px; height: 60px; bottom: 30px; right: 120px; }
        #btn-build { width: 60px; height: 60px; bottom: 160px; right: 50px; background: rgba(139, 69, 19, 0.6); }
        #stick-zone {
            position: absolute; bottom: 30px; left: 30px; width: 100px; height: 100px;
            border: 2px dashed rgba(255,255,255,0.3); border-radius: 50%;
            pointer-events: none; opacity: 0.4; transition: opacity 0.2s;
        }
        #stick-knob {
            position: absolute; top: 50%; left: 50%; width: 40px; height: 40px;
            background: rgba(255,255,255,0.6); border-radius: 50%;
            transform: translate(-50%, -50%); border: 2px solid rgba(255,255,255,0.8);
        }

        /* === Êñ∞Ë¶èËøΩÂä†CSS („É¢„Éº„ÉâÈÅ∏Êäû„ÉªÁ•ûÁµåË°∞Âº±Áî®) === */
        .full-screen-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .hidden { display: none !important; }
        
        input[type="text"], select {
            padding: 15px; font-size: 18px; margin: 10px; width: 300px; max-width: 80%;
            border: 2px solid #4caf50; border-radius: 5px; text-align: center; color: black;
        }
        .menu-btn {
            padding: 15px 40px; font-size: 20px; margin: 10px;
            border: none; border-radius: 8px; cursor: pointer; color: white; font-weight: bold;
            min-width: 200px; box-shadow: 0 4px 0 rgba(0,0,0,0.5);
        }
        .btn-green { background: #4caf50; }
        .btn-green:hover { background: #45a049; }
        .btn-blue { background: #2196f3; }
        .btn-red { background: #f44336; }
        
        #lobby-ui { align-items: flex-start; padding-top: 60px; }
        #room-list-container {
            width: 90%; max-width: 600px; height: 60%; background: rgba(255,255,255,0.1);
            margin: 20px auto; border-radius: 10px; overflow-y: auto; padding: 10px;
        }
        .room-entry {
            background: rgba(0,0,0,0.5); padding: 15px; margin-bottom: 10px; border-radius: 5px;
            display: flex; justify-content: space-between; align-items: center; border: 1px solid #555;
        }
        #waiting-players { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; margin: 20px; }
        .player-card { background: #333; padding: 15px; border-radius: 5px; border: 1px solid #4caf50; min-width: 80px; text-align: center;}
        
        /* Á•ûÁµåË°∞Âº±„Ç≤„Éº„É†Áõ§ (‰øÆÊ≠£Áâà) */
        #memory-game-board {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 20px;
        }
        .card {
            width: 60px; height: 80px; background: #1e88e5; border-radius: 8px;
            display: flex; justify-content: center; align-items: center;
            font-size: 32px; font-weight: bold; cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            color: transparent;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .card:not(.flipped):not(.matched):hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        .card.disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
        .card::before {
            content: '?';
            position: absolute;
            color: white;
            font-size: 40px;
        }
        .card.flipped, .card.matched { 
            background: #fff; 
            color: #000;
        }
        .card.flipped::before, .card.matched::before {
            content: '';
        }
        .card.matched { 
            background: #4caf50; 
            color: #fff; 
            opacity: 0.6; 
            pointer-events: none;
        }
        #memory-status {
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
            margin: 10px;
        }
    </style>
</head>
<body>

    <div id="username-screen" class="full-screen-menu">
        <h1>üéÆ Enter Your Name</h1>
        <input type="text" id="username-input" placeholder="Your Username" maxlength="12" />
        <button id="username-btn" class="menu-btn btn-green">ENTER</button>
    </div>

    <div id="mode-select-screen" class="full-screen-menu hidden">
        <h1>SELECT MODE</h1>
        <h3 id="welcome-msg"></h3>
        <button class="menu-btn btn-red" onclick="selectMode('BR')">üî´ Battle Royale</button>
        <button class="menu-btn btn-blue" onclick="selectMode('MEMORY')">üÉè Á•ûÁµåË°∞Âº± (Memory)</button>
    </div>

    <div id="lobby-screen" class="full-screen-menu hidden" style="justify-content: flex-start;">
        <div style="width:100%; padding:20px; display:flex; justify-content:space-between; box-sizing:border-box;">
            <button class="menu-btn btn-green" style="padding:10px 20px;" onclick="showCreateRoom()">Ôºã Create Room</button>
            <button class="menu-btn btn-red" style="padding:10px 20px;" onclick="backToMode()">Back</button>
        </div>
        <h2>Current Rooms</h2>
        <div id="room-list-container">Loading...</div>
    </div>

    <div id="create-room-screen" class="full-screen-menu hidden" style="background:rgba(0,0,0,0.98);">
        <h2>Create Room</h2>
        <input type="text" id="room-name" placeholder="Room Name">
        <select id="room-size">
            <option value="2">2 Players</option>
            <option value="3">3 Players</option>
            <option value="4">4 Players</option>
        </select>
        <button class="menu-btn btn-green" onclick="createRoomExec()">Open Room</button>
        <button class="menu-btn btn-red" onclick="document.getElementById('create-room-screen').classList.add('hidden')">Cancel</button>
    </div>

    <div id="waiting-room-screen" class="full-screen-menu hidden">
        <h2 id="current-room-name">Room Name</h2>
        <p>Waiting for players...</p>
        <div id="waiting-players"></div>
        <div id="host-controls" class="hidden">
            <button class="menu-btn btn-green" onclick="startGameMemoryHost()">GAME START</button>
        </div>
        <button class="menu-btn btn-red" style="margin-top:30px;" onclick="leaveRoom()">Leave</button>
    </div>

    <div id="memory-game-screen" class="full-screen-menu hidden">
        <div style="position:absolute; top:20px; left:20px;">
            <button class="menu-btn btn-red" style="padding:5px 15px; font-size:14px;" onclick="leaveRoom()">Exit</button>
        </div>
        <h2>üÉè Memory Game</h2>
        <h3 id="memory-status">Waiting...</h3>
        <div id="memory-game-board"></div>
    </div>

    <div id="game-over">
        <h1>YOU DIED</h1>
        <p id="final-score">Kills: 0</p>
        <button id="restart-btn" onclick="location.reload()">RESTART</button>
    </div>

    <div id="ui-layer">
        <div id="status-bar">
            <div id="hp-bar">HP: 100</div>
            <div id="score-bar">Kills: 0</div>
            <div id="players-bar">Players: 1</div>
        </div>
        <div id="connection-status">üî¥ Connecting...</div>
        <div id="crosshair"></div>
        
        <div id="chat-container">
            <div id="chat-messages"></div>
            <div id="chat-input-container">
                <input type="text" id="chat-input" placeholder="Type message..." maxlength="100" />
                <button id="chat-send">Send</button>
            </div>
        </div>
        
        <div id="stick-zone"><div id="stick-knob"></div></div>
        <div id="btn-shoot" class="control-btn">FIRE</div>
        <div id="btn-jump" class="control-btn">JUMP</div>
        <div id="btn-build" class="control-btn">WALL</div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- FirebaseÂàùÊúüÂåñ ---
        const firebaseConfig = {
            apiKey: "AIzaSyBIB7NiNQBbrxNc0dsKtHmdGbieHrI26dk",
            databaseURL: "https://online-game-f5701-default-rtdb.asia-southeast1.firebasedatabase.app"
        };
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const db = firebase.database();

        let username = '';
        let myPlayerId = 'p_' + Math.random().toString(36).substr(2, 9);
        
        const usernameScreen = document.getElementById('username-screen');
        const usernameInput = document.getElementById('username-input');
        const usernameBtn = document.getElementById('username-btn');
        const modeScreen = document.getElementById('mode-select-screen');
        
        usernameBtn.addEventListener('click', () => {
            const val = usernameInput.value.trim();
            if (!val) { alert('„É¶„Éº„Ç∂„ÉºÂêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ'); return; }
            username = val;
            usernameScreen.classList.add('hidden');
            modeScreen.classList.remove('hidden');
            document.getElementById('welcome-msg').innerText = `Welcome, ${username}`;
        });

        window.selectMode = function(mode) {
            modeScreen.classList.add('hidden');
            if (mode === 'BR') {
                startBattleRoyale();
            } else {
                initMemoryLobby();
            }
        };

        window.backToMode = function() {
            document.getElementById('lobby-screen').classList.add('hidden');
            modeScreen.classList.remove('hidden');
        }

        /* =========================================
           Á•ûÁµåË°∞Âº± (Memory Game) - ÂÆåÂÖ®‰øÆÊ≠£Áâà
           ========================================= */
        let currentRoomId = null;
        let isHost = false;
        let isProcessing = false;
        let gameBoard = [];
        let flippedCards = [];
        let currentTurnIndex = 0;
        let playerNames = [];
        let scores = {};
        let moveListener = null;
        let myTurnIndex = -1; // Ëá™ÂàÜ„ÅÆ„Çø„Éº„É≥Áï™Âè∑

        function initMemoryLobby() {
            document.getElementById('lobby-screen').classList.remove('hidden');
            db.ref('memory_rooms').on('value', snap => {
                const list = document.getElementById('room-list-container');
                list.innerHTML = '';
                const rooms = snap.val();
                if (!rooms) { list.innerHTML = '<p>No rooms available.</p>'; return; }

                for (let rid in rooms) {
                    const r = rooms[rid];
                    if (r.status === 'waiting') {
                        const pCount = r.players ? Object.keys(r.players).length : 0;
                        const div = document.createElement('div');
                        div.className = 'room-entry';
                        div.innerHTML = `
                            <div><strong>${r.name}</strong> (${pCount}/${r.max})</div>
                            <button class="menu-btn btn-blue" style="padding:5px 15px; margin:0; min-width:80px;" 
                                onclick="joinRoom('${rid}')" ${pCount >= r.max ? 'disabled' : ''}>Join</button>
                        `;
                        list.appendChild(div);
                    }
                }
            });
        }

        window.showCreateRoom = function() {
            document.getElementById('create-room-screen').classList.remove('hidden');
        };

        window.createRoomExec = function() {
            const rName = document.getElementById('room-name').value || `${username}'s Room`;
            const rMax = parseInt(document.getElementById('room-size').value);
            
            const newRef = db.ref('memory_rooms').push();
            currentRoomId = newRef.key;
            isHost = true;

            newRef.set({
                name: rName, 
                max: rMax, 
                host: username, 
                status: 'waiting',
                players: { [myPlayerId]: { name: username } }
            }).then(() => {
                document.getElementById('create-room-screen').classList.add('hidden');
                document.getElementById('lobby-screen').classList.add('hidden');
                enterWaitingRoom();
            });
        };

        window.joinRoom = function(rid) {
            currentRoomId = rid;
            isHost = false;
            db.ref(`memory_rooms/${rid}/players/${myPlayerId}`).set({ name: username })
            .then(() => {
                document.getElementById('lobby-screen').classList.add('hidden');
                enterWaitingRoom();
            });
        };

        function enterWaitingRoom() {
            const screen = document.getElementById('waiting-room-screen');
            screen.classList.remove('hidden');
            
            db.ref(`memory_rooms/${currentRoomId}`).on('value', snap => {
                const r = snap.val();
                if (!r) { alert('Room closed.'); location.reload(); return; }
                
                document.getElementById('current-room-name').innerText = r.name;
                const pList = document.getElementById('waiting-players');
                pList.innerHTML = '';
                if(r.players) {
                    Object.values(r.players).forEach(p => {
                        const c = document.createElement('div');
                        c.className = 'player-card';
                        c.innerText = p.name;
                        pList.appendChild(c);
                    });
                }

                if (isHost) document.getElementById('host-controls').classList.remove('hidden');

                if (r.status === 'playing') {
                    screen.classList.add('hidden');
                    startMemoryGame(r);
                }
            });
        }

        window.startGameMemoryHost = function() {
            const cards = [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]
                .sort(() => Math.random() - 0.5);
            
            // Âè§„ÅÑmoves„Çí„ÇØ„É™„Ç¢ & Êñ∞„Åó„ÅÑ„Ç≤„Éº„É†ÈñãÂßã
            db.ref(`memory_rooms/${currentRoomId}`).update({
                status: 'playing',
                board: cards,
                turnIndex: 0,
                moves: null, // ÈáçË¶Å: Âè§„ÅÑÂ±•Ê≠¥„ÇíÂâäÈô§
                scores: {}
            });
        };

        window.leaveRoom = function() {
            if (currentRoomId) {
                // „É™„Çπ„Éä„Éº„ÇíËß£Èô§
                if (moveListener) {
                    db.ref(`memory_rooms/${currentRoomId}/moves`).off('child_added', moveListener);
                }
                
                if(isHost) {
                    db.ref(`memory_rooms/${currentRoomId}`).remove();
                } else {
                    db.ref(`memory_rooms/${currentRoomId}/players/${myPlayerId}`).remove();
                }
            }
            location.reload();
        };

        function startMemoryGame(roomData) {
            const screen = document.getElementById('memory-game-screen');
            screen.classList.remove('hidden');
            const board = document.getElementById('memory-game-board');
            board.innerHTML = '';

            gameBoard = roomData.board;
            flippedCards = [];
            isProcessing = false;
            
            // „Éó„É¨„Ç§„É§„ÉºÂêç„É™„Çπ„Éà„Çí‰ΩúÊàê
            const playerEntries = Object.entries(roomData.players);
            playerNames = playerEntries.map(([id, p]) => p.name);
            
            // Ëá™ÂàÜ„Åå‰ΩïÁï™ÁõÆ„ÅÆ„Éó„É¨„Ç§„É§„Éº„Åã„ÇíË®òÈå≤
            myTurnIndex = playerEntries.findIndex(([id, p]) => id === myPlayerId);
            
            scores = roomData.scores || {};
            playerNames.forEach(name => {
                if (!scores[name]) scores[name] = 0;
            });

            // „Ç´„Éº„ÉâÁîüÊàê
            gameBoard.forEach((num, idx) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.textContent = num;
                card.onclick = () => flipCard(idx, num);
                card.id = `card-${idx}`;
                board.appendChild(card);
            });

            updateStatus(roomData.turnIndex || 0);

            // Êó¢Â≠ò„ÅÆ„É™„Çπ„Éä„Éº„ÇíÂâäÈô§„Åó„Å¶„Åã„ÇâÊñ∞„Åó„ÅÑ„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
            if (moveListener) {
                db.ref(`memory_rooms/${currentRoomId}/moves`).off('child_added', moveListener);
            }

            // moves„ÇíÁõ£Ë¶ñÔºàÊñ∞Ë¶èËøΩÂä†ÂàÜ„ÅÆ„ÅøÔºâ
            let isFirstLoad = true;
            moveListener = db.ref(`memory_rooms/${currentRoomId}/moves`).on('child_added', snap => {
                // ÂàùÂõûË™≠„ÅøËæº„ÅøÊôÇ„ÅØÊó¢Â≠ò„ÅÆÂ±•Ê≠¥„Çí„Çπ„Ç≠„ÉÉ„Éó
                if (isFirstLoad) {
                    isFirstLoad = false;
                    // Êó¢„Å´2Êûö„ÇÅ„Åè„Çâ„Çå„Å¶„ÅÑ„ÇãÁä∂ÊÖã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                    const allMoves = [];
                    db.ref(`memory_rooms/${currentRoomId}/moves`).once('value', s => {
                        s.forEach(child => allMoves.push(child.val()));
                        
                        // Êó¢Â≠ò„ÅÆÂ±•Ê≠¥„ÇíÂèçÊò†
                        allMoves.forEach(m => {
                            const el = document.getElementById(`card-${m.index}`);
                            if (el && !el.classList.contains('matched')) {
                                el.classList.add('flipped');
                            }
                        });
                        
                        // 2ÊûöÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÂà§ÂÆö
                        const flipped = document.querySelectorAll('.card.flipped:not(.matched)');
                        if (flipped.length === 2) {
                            checkMatch();
                        }
                    });
                    return;
                }

                // Êñ∞„Åó„ÅÑmove„ÇíÂá¶ÁêÜ
                const m = snap.val();
                const el = document.getElementById(`card-${m.index}`);
                if (el && !el.classList.contains('matched')) {
                    el.classList.add('flipped');
                }
                
                // 2Êûö„ÇÅ„Åè„Çâ„Çå„Åü„ÇâÂà§ÂÆö
                const flipped = document.querySelectorAll('.card.flipped:not(.matched)');
                if (flipped.length === 2) {
                    checkMatch();
                }
            });

            // „Çø„Éº„É≥Áõ£Ë¶ñ
            db.ref(`memory_rooms/${currentRoomId}/turnIndex`).on('value', snap => {
                const turn = snap.val() || 0;
                updateStatus(turn);
                
                // „Ç´„Éº„Éâ„ÅÆÊúâÂäπ/ÁÑ°Âäπ„ÇíÂàá„ÇäÊõø„Åà
                const isMyTurn = (turn % playerNames.length) === myTurnIndex;
                document.querySelectorAll('.card:not(.matched)').forEach(card => {
                    if (isMyTurn) {
                        card.classList.remove('disabled');
                    } else {
                        card.classList.add('disabled');
                    }
                });
            });
        }

        function updateStatus(turnIdx) {
            currentTurnIndex = turnIdx;
            const currentPlayer = playerNames[turnIdx % playerNames.length];
            const statusEl = document.getElementById('memory-status');
            
            let scoreText = '';
            for (let name in scores) {
                scoreText += `${name}: ${scores[name]} | `;
            }
            
            const isMyTurn = (turnIdx % playerNames.length) === myTurnIndex;
            const turnIndicator = isMyTurn ? 'üëâ YOUR TURN! üëà' : '‚è≥ Waiting...';
            
            statusEl.innerHTML = `${turnIndicator}<br>Turn: <strong>${currentPlayer}</strong><br>${scoreText}`;
            statusEl.style.color = isMyTurn ? '#4caf50' : '#ffffff';
        }

        function checkMatch() {
            if (isProcessing) return;
            isProcessing = true;

            const flipped = document.querySelectorAll('.card.flipped:not(.matched)');
            
            setTimeout(() => {
                if (flipped[0].textContent === flipped[1].textContent) {
                    // „Éû„ÉÉ„ÉÅÊàêÂäü
                    flipped[0].classList.add('matched');
                    flipped[1].classList.add('matched');
                    
                    // „Çπ„Ç≥„Ç¢Âä†ÁÆó
                    const currentPlayer = playerNames[currentTurnIndex % playerNames.length];
                    scores[currentPlayer] = (scores[currentPlayer] || 0) + 1;
                    
                    // „Çπ„Ç≥„Ç¢„ÇíÊõ¥Êñ∞
                    db.ref(`memory_rooms/${currentRoomId}/scores`).set(scores);
                    
                    // ÂÖ®„Å¶„Éû„ÉÉ„ÉÅ„Åó„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                    const allMatched = document.querySelectorAll('.card.matched').length === 16;
                    if (allMatched) {
                        setTimeout(() => {
                            let winner = '';
                            let maxScore = 0;
                            for (let name in scores) {
                                if (scores[name] > maxScore) {
                                    maxScore = scores[name];
                                    winner = name;
                                }
                            }
                            alert(`üéâ Game Over! Winner: ${winner} (${maxScore} pairs)`);
                            leaveRoom();
                        }, 500);
                    }
                } else {
                    // „Éû„ÉÉ„ÉÅÂ§±Êïó
                    flipped[0].classList.remove('flipped');
                    flipped[1].classList.remove('flipped');
                    
                    // „Çø„Éº„É≥‰∫§‰ª£
                    const nextTurn = currentTurnIndex + 1;
                    db.ref(`memory_rooms/${currentRoomId}/turnIndex`).set(nextTurn);
                }
                
                // moves„Çí„ÇØ„É™„Ç¢ÔºàÊ¨°„ÅÆ„Çø„Éº„É≥Áî®Ôºâ
                db.ref(`memory_rooms/${currentRoomId}/moves`).remove();
                isProcessing = false;
            }, 1000);
        }

        function flipCard(idx, num) {
            // Ëá™ÂàÜ„ÅÆ„Çø„Éº„É≥„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            const isMyTurn = (currentTurnIndex % playerNames.length) === myTurnIndex;
            if (!isMyTurn) {
                // Ëá™ÂàÜ„ÅÆ„Çø„Éº„É≥„Åß„Å™„ÅÑÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
                return;
            }
            
            // Âá¶ÁêÜ‰∏≠„Åæ„Åü„ÅØÊó¢„Å´„ÇÅ„Åè„Çâ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
            if (isProcessing) return;
            
            const el = document.getElementById(`card-${idx}`);
            if (el.classList.contains('flipped') || el.classList.contains('matched')) return;
            
            // Êó¢„Å´2ÊûöÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
            const openCards = document.querySelectorAll('.card.flipped:not(.matched)');
            if (openCards.length >= 2) return;

            // „Çµ„Éº„Éê„Éº„Å´ÈÄÅ‰ø°
            db.ref(`memory_rooms/${currentRoomId}/moves`).push({ 
                index: idx, 
                val: num,
                timestamp: Date.now()
            });
        }


        /* =========================================
           „Éê„Éà„É´„É≠„ÉØ„Ç§„É§„É´ (Battle Royale)
           (Â§âÊõ¥„Å™„Åó)
           ========================================= */
        function startBattleRoyale() {
            document.getElementById('ui-layer').style.display = 'block'; 
            
            const hpEl = document.getElementById('hp-bar');
            const scoreEl = document.getElementById('score-bar');
            const playersEl = document.getElementById('players-bar');
            const gameOverEl = document.getElementById('game-over');
            const finalScoreEl = document.getElementById('final-score');
            const chatMessages = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const chatSend = document.getElementById('chat-send');
            const connectionStatus = document.getElementById('connection-status');

            let myPlayerRef = null;
            let gameStarted = true;
            let adminMode = false;
            let isGameOver = false;
            let score = 0;
            let playerHP = 100;
            const enemies = [];
            const bullets = [];
            const walls = [];
            const otherPlayers = {};

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 500);

            const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 800);
            camera.rotation.order = 'YXZ'; 

            const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.HemisphereLight(0xeeeeff, 0x555555, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            scene.add(dirLight);

            const floorGeo = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            floorGeo.rotateX(-Math.PI / 2);
            const positions = floorGeo.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getZ(i);
                const height = Math.sin(x * 0.01) * 5 + Math.cos(z * 0.01) * 5 + 
                              Math.sin(x * 0.02 + z * 0.02) * 3 +
                              Math.random() * 2;
                positions.setY(i, height);
            }
            floorGeo.computeVertexNormals();
            const floorMat = new THREE.MeshLambertMaterial({ color: 0x4caf50, flatShading: true });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            scene.add(floor);

            const player = { height: 10, speed: 80.0, velocity: new THREE.Vector3(), canJump: false };
            camera.position.set(0, player.height + 20, 0);

            myPlayerRef = db.ref('players/' + myPlayerId);
            connectionStatus.innerText = 'üü¢ Connected';
            connectionStatus.style.color = '#00ff00';

            setInterval(() => {
                if (!isGameOver) {
                    myPlayerRef.set({
                        x: camera.position.x, y: camera.position.y, z: camera.position.z,
                        rotY: camera.rotation.y, hp: playerHP, username: username, timestamp: Date.now()
                    });
                }
            }, 100);

            db.ref('players').on('value', (snapshot) => {
                const players = snapshot.val();
                const currentPlayerIds = new Set();
                
                if (players) {
                    for (let id in players) {
                        currentPlayerIds.add(id);
                        if (id === myPlayerId) continue;
                        const pData = players[id];
                        if (Date.now() - pData.timestamp > 30000) continue; 
                        
                        if (!otherPlayers[id]) {
                            const pGeo = new THREE.BoxGeometry(5, 18, 5);
                            const pMat = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.8 });
                            const pMesh = new THREE.Mesh(pGeo, pMat);
                            
                            const canvas = document.createElement('canvas');
                            canvas.width = 256; canvas.height = 64;
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0, 0, 256, 64);
                            ctx.fillStyle = 'white'; ctx.font = 'bold 32px Arial';
                            ctx.textAlign = 'center'; ctx.fillText(pData.username || 'Player', 128, 42);
                            const tex = new THREE.CanvasTexture(canvas);
                            const nameMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 3), new THREE.MeshBasicMaterial({ map: tex, transparent: true }));
                            nameMesh.position.y = 12;
                            pMesh.add(nameMesh);
                            pMesh.userData.nameTag = nameMesh;
                            
                            scene.add(pMesh);
                            otherPlayers[id] = pMesh;
                        }
                        
                        const mesh = otherPlayers[id];
                        mesh.position.lerp(new THREE.Vector3(pData.x, pData.y - 9, pData.z), 0.3);
                        mesh.rotation.y = pData.rotY;
                        if (mesh.userData.nameTag) mesh.userData.nameTag.lookAt(camera.position);
                    }
                }
                for (let id in otherPlayers) {
                    if (!currentPlayerIds.has(id)) {
                        scene.remove(otherPlayers[id]); delete otherPlayers[id];
                    }
                }
                playersEl.innerText = `Players: ${currentPlayerIds.size}`;
            });

            window.addEventListener('beforeunload', () => { if (myPlayerRef) myPlayerRef.remove(); });
            setInterval(() => {
                db.ref('players').once('value', (s) => {
                    const ps = s.val();
                    if(ps) for(let id in ps) if(Date.now()-ps[id].timestamp>60000) db.ref('players/'+id).remove();
                });
            }, 30000);

            function sendMessage() {
                const msg = chatInput.value.trim();
                if (!msg) return;
                if (msg === ';admin') {
                    adminMode = !adminMode;
                    chatInput.value = '';
                    const m = document.createElement('div'); m.className = 'chat-message';
                    m.innerHTML = `<span style="color:red;">[SYSTEM] Admin ${adminMode?'ON':'OFF'}</span>`;
                    chatMessages.appendChild(m);
                    return;
                }
                db.ref('chat').push({ username: username, message: msg, timestamp: Date.now() });
                chatInput.value = '';
            }
            chatSend.addEventListener('click', sendMessage);
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') sendMessage(); });
            
            db.ref('chat').limitToLast(20).on('child_added', (s) => {
                const d = s.val();
                const m = document.createElement('div'); m.className = 'chat-message';
                m.innerHTML = `<span class="chat-username">${d.username}:</span> ${d.message}`;
                chatMessages.appendChild(m);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            });

            const enemyGeo = new THREE.BoxGeometry(6, 12, 6);
            const enemyMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            setInterval(() => {
                if (isGameOver || !gameStarted || enemies.length >= 10) return;
                const e = new THREE.Mesh(enemyGeo, enemyMat);
                const a = Math.random() * Math.PI * 2;
                const d = 100 + Math.random() * 200;
                e.position.set(camera.position.x + Math.cos(a)*d, 10, camera.position.z + Math.sin(a)*d);
                scene.add(e);
                enemies.push({ mesh: e, speed: 20 + Math.random() * 15 });
            }, 2000);

            const input = { moveX: 0, moveY: 0, touches: {} };
            const stickZone = document.getElementById('stick-zone');
            const stickKnob = document.getElementById('stick-knob');
            
            document.addEventListener('touchstart', (e) => {
                if(isGameOver || !gameStarted) return;
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.clientX < 150 && t.clientY > window.innerHeight - 150) {
                        input.touches[t.identifier] = { type: 'move', startX: t.clientX, startY: t.clientY };
                        stickZone.style.left = (t.clientX - 50) + 'px'; stickZone.style.top = (t.clientY - 50) + 'px';
                        stickZone.style.opacity = '0.8';
                    } else {
                        input.touches[t.identifier] = { type: 'look', lastX: t.clientX, lastY: t.clientY };
                    }
                }
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if(isGameOver || !gameStarted) return;
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    const d = input.touches[t.identifier];
                    if (d && d.type === 'move') {
                        const dx = t.clientX - d.startX; const dy = t.clientY - d.startY;
                        input.moveX = Math.max(-1, Math.min(1, dx / 50));
                        input.moveY = Math.max(-1, Math.min(1, -dy / 50));
                        stickKnob.style.transform = `translate(calc(-50% + ${input.moveX * 25}px), calc(-50% + ${-input.moveY * 25}px))`;
                    } else if (d && d.type === 'look') {
                        camera.rotation.y -= (t.clientX - d.lastX) * 0.005;
                        camera.rotation.x -= (t.clientY - d.lastY) * 0.005;
                        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                        d.lastX = t.clientX; d.lastY = t.clientY;
                    }
                }
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (input.touches[t.identifier]?.type === 'move') {
                        input.moveX = 0; input.moveY = 0;
                        stickKnob.style.transform = `translate(-50%, -50%)`; stickZone.style.opacity = '0.4';
                    }
                    delete input.touches[t.identifier];
                }
            });

            document.getElementById('btn-jump').addEventListener('touchstart', (e) => {
                e.stopPropagation(); if (!isGameOver && player.canJump) { player.velocity.y = 120; player.canJump = false; }
            });

            let shootInterval;
            document.getElementById('btn-shoot').addEventListener('touchstart', (e) => {
                e.stopPropagation(); if (!isGameOver) {
                    shoot();
                    if(adminMode) shootInterval = setInterval(shoot, 150);
                }
            });
            document.getElementById('btn-shoot').addEventListener('touchend', () => clearInterval(shootInterval));
            document.getElementById('btn-build').addEventListener('touchstart', (e) => { e.stopPropagation(); if(!isGameOver) buildWall(); });

            function shoot() {
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                b.position.copy(camera.position); b.position.y -= 1;
                let dir;
                if (adminMode && enemies.length > 0) {
                    let closest = null, minDst = Infinity;
                    enemies.forEach(e => { const d = b.position.distanceTo(e.mesh.position); if(d<minDst){minDst=d; closest=e;} });
                    if(closest) dir = new THREE.Vector3().subVectors(closest.mesh.position, b.position).normalize();
                    else dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                } else {
                    dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
                }
                b.userData = { velocity: dir.multiplyScalar(400) };
                scene.add(b); bullets.push(b);
            }

            function buildWall() {
                const w = new THREE.Mesh(new THREE.BoxGeometry(15,15,2), new THREE.MeshBasicMaterial({ color: 0x8B4513 }));
                const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); dir.y=0; dir.normalize();
                const pos = camera.position.clone().add(dir.multiplyScalar(20));
                w.position.set(Math.round(pos.x/15)*15, 7.5, Math.round(pos.z/15)*15);
                w.lookAt(w.position.clone().add(dir));
                w.userData = { hp: 3 }; scene.add(w); walls.push(w);
            }

            let prevTime = performance.now();
            function animate() {
                if (isGameOver || !gameStarted) return;
                requestAnimationFrame(animate);
                const time = performance.now();
                const delta = Math.min((time - prevTime) / 1000, 0.1);
                prevTime = time;

                player.velocity.y -= 9.8 * 30.0 * delta;
                const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fwd.y=0; fwd.normalize();
                const rgt = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); rgt.y=0; rgt.normalize();
                const move = fwd.multiplyScalar(input.moveY).add(rgt.multiplyScalar(input.moveX));
                
                player.velocity.x = move.x * player.speed; player.velocity.z = move.z * player.speed;
                camera.position.add(player.velocity.clone().multiplyScalar(delta));

                if (camera.position.y < player.height + 20) {
                    camera.position.y = player.height + 20; player.velocity.y = 0; player.canJump = true;
                }

                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    e.mesh.lookAt(camera.position.x, e.mesh.position.y, camera.position.z);
                    const dir = camera.position.clone().sub(e.mesh.position).normalize(); dir.y=0;
                    
                    let blocked = false;
                    const nextPos = e.mesh.position.clone().add(dir.multiplyScalar(e.speed * delta));
                    for(let w of walls) { if(nextPos.distanceTo(w.position) < 10) blocked=true; }
                    
                    if(!blocked) e.mesh.position.copy(nextPos);

                    if (e.mesh.position.distanceTo(camera.position) < 5) {
                        playerHP--; hpEl.innerText = `HP: ${playerHP}`;
                        hpEl.style.color='red'; setTimeout(()=>hpEl.style.color='#00ff00',100);
                        e.mesh.position.sub(dir.multiplyScalar(10));
                        if (playerHP <= 0) {
                            isGameOver = true; gameOverEl.style.display = 'flex'; finalScoreEl.innerText = `Kills: ${score}`;
                            if (myPlayerRef) myPlayerRef.remove();
                        }
                    }
                }

                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    b.position.add(b.userData.velocity.clone().multiplyScalar(delta));
                    let hit = false;
                    
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        if (b.position.distanceTo(enemies[j].mesh.position) < 8) {
                            scene.remove(enemies[j].mesh); enemies.splice(j, 1);
                            scene.remove(b); bullets.splice(i, 1); hit = true;
                            score++; scoreEl.innerText = `Kills: ${score}`; break;
                        }
                    }
                    if (!hit) {
                        for (let k = walls.length - 1; k >= 0; k--) {
                            if (b.position.distanceTo(walls[k].position) < 12) {
                                scene.remove(b); bullets.splice(i, 1); hit = true;
                                walls[k].userData.hp--;
                                walls[k].material.color.setHSL(0.08, 0.74, 0.2 + (0.2 * walls[k].userData.hp/3));
                                if (walls[k].userData.hp <= 0) { scene.remove(walls[k]); walls.splice(k, 1); }
                                break;
                            }
                        }
                    }
                    if (!hit && b.position.distanceTo(camera.position) > 400) {
                        scene.remove(b); bullets.splice(i, 1);
                    }
                }
                renderer.render(scene, camera);
            }
            animate();
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>
